{
	// Place your cpp 工作区 snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	"BATCH": {
		"prefix": "TemplateBATCH",
		"body": [
			"#ifdef BATCH",
			"    freopen(argv[1], \"r\", stdin);",
			"    freopen(argv[2], \"w\", stdout);",
			"#endif"
		],
		"description": "BATCH"
	},
	"codeforceL": {
		"prefix": "codeforce",
		"body": [
			"#include <iostream>",
			"",
			"#pragma GCC optimize(\"Ofast,unroll-loops\")",
			"#pragma GCC target(\"avx2,popcnt\")",
			"using namespace std;",
			"using ll   = long long;",
			"using u8   = uint8_t;",
			"using u16  = uint16_t;",
			"using u32  = uint32_t;",
			"using i64  = long long;",
			"using u64  = uint64_t;",
			"using i128 = __int128;",
			"using u128 = unsigned __int128;",
			"using f128 = __float128;",
			"",
			"// vectors",
			"#define len(x)  int(x.size())",
			"#define sz(x)   int(size(x))",
			"#define bg(x)   begin(x)",
			"#define all(x)  bg(x), end(x)",
			"#define rall(x) rbegin(x), rend(x)",
			"#define sor(x)  sort(all(x))",
			"#define rsz     resize",
			"#define ins     insert",
			"#define pb      push_back",
			"#define eb      emplace_back",
			"#define ft      front()",
			"#define bk      back()",
			"#define mp      make_pair",
			"#define mt      make_tuple",
			"#define fi      first",
			"#define se      second",
			"",
			"// https://trap.jp/post/1224/",
			"#define FOR1(a)                       for (i64 _ = 0; _ < i64(a); ++_)",
			"#define FOR2(i, a)                    for (i64 i = 0; i < i64(a); ++i)",
			"#define FOR3(i, a, b)                 for (i64 i = a; i < i64(b); ++i)",
			"#define FOR4(i, a, b, c)              for (i64 i = a; i < i64(b); i += (c))",
			"#define FOR1_R(a)                     for (i64 i = (a) - 1; i >= i64(0); --i)",
			"#define FOR2_R(i, a)                  for (i64 i = (a) - 1; i >= i64(0); --i)",
			"#define FOR3_R(i, a, b)               for (i64 i = (b) - 1; i >= i64(a); --i)",
			"#define overload4(a, b, c, d, e, ...) e",
			"#define overload3(a, b, c, d, ...)    d",
			"#define FOR(...)                      overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)",
			"#define FOR_R(...)                    overload3(__VA_ARGS__, FOR3_R, FOR2_R, FOR1_R)(__VA_ARGS__)",
			"",
			"constexpr int INF = 1e9;",
			"",
			"signed main(signed argc, char** argv)",
			"{",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(0);",
			"    cout.tie(0);",
			"#ifdef BATCH",
			"    freopen(argv[1], \"r\", stdin);",
			"    freopen(argv[2], \"w\", stdout);",
			"#endif",
			"    $1",
			"    return 0;",
			"}",
			"",
			"/* stuff you should look for",
			" * int overflow, array bounds",
			" * special cases (n=1?)",
			" * do smth instead of nothing and stay organized",
			" * WRITE STUFF DOWN",
			" * DON'T GET STUCK ON ONE APPROACH",
			" */"
		],
		"description": "codeforce"
	},
	"quickio": {
		"scope": "cpp",
		"prefix": "Templatequickio",
		"body": [
			"int init(){",
			"    char c = getchar();",
			"    int x = 0, f = 1;",
			"    for (; c < '0' || c > '9'; c = getchar())",
			"        if (c == '-') f = -1;",
			"    for (; c >= '0' && c <= '9'; c = getchar())",
			"        x = (x << 1) + (x << 3) + (c ^ 48);",
			"    return x * f;",
			"}",
			"void print(int x){",
			"    if (x < 0) x = -x, putchar('-');",
			"    if (x > 9) print(x / 10);",
			"    putchar(x % 10 + '0');",
			"}"
		],
		"description": "The quick input and out put"
	},
	"quick_pow": {
		"prefix": "Templateqpow",
		"body": [
			"i64 qpow(i64 n, i64 q, i64 mod = MOD) {",
			"    if (q == 0) {",
			"        return 1;",
			"    }",
			"    i64 ans = 1;",
			"    while (q > 0) {",
			"        if (q & 1) {",
			"            ans *= n;",
			"            ans %= mod;",
			"        }",
			"        n *= n;",
			"        n %= mod;",
			"        q >>= 1;",
			"    }",
			"    return ans;",
			"}"
		],
		"description": "quick_pow"
	},
	"extend_gcd": {
		"scope": "cpp",
		"prefix": "Templateexgcd",
		"body": [
			"tuple<i64, i64, i64> exgcd(i64 a, i64 b) // 找到a*x + b*y = r",
			"{",
			"    if (b == 0)",
			"    {",
			"        return {1, 0, a};",
			"    }",
			"    auto [lx, ly, r] = exgcd(b, a % b);",
			"    // lx * b + ly * (a % b) = r",
			"    // lx * b + ly * (a - (a / b) * b) = r",
			"    // b * (lx - ly * (a / b)) + a * ly = r",
			"    i64 x = ly;",
			"    i64 y = lx - ly * (a / b);",
			"    return {x, y, r};",
			"}"
		],
		"description": "exgcd -std=c++17"
	},
	"UnionFind": {
		"prefix": "TemplateUnionFind",
		"body": [
			"class UnionFind {",
			"private:",
			"    std::vector<int> parent;",
			"    std::vector<int> rank;  // 记录每个树的秩（深度）",
			"    int              count;",
			"    int const        N;",
			"",
			"public:",
			"    UnionFind(int n) : parent(n), rank(n, 0), count(n), N(n) {",
			"        for (int i = 0; i < n; ++i) {",
			"            parent[i] = i;",
			"        }",
			"    }",
			"",
			"    // 验证",
			"    void validate(int x) {",
			"        if (x < 0 || x >= N) {",
			"            throw out_of_range(\"Expected X : 0~\" + to_string(N) + \" But get \" + to_string(x));",
			"        }",
			"    }",
			"",
			"    // 查找根节点，并进行路径压缩",
			"    int find(int x) {",
			"        validate(x);",
			"        if (parent[x] != x) {",
			"            parent[x] = find(parent[x]);  // 路径压缩",
			"        }",
			"        return parent[x];",
			"    }",
			"",
			"    // 合并两个集合",
			"    void unionSets(int x, int y) {",
			"        validate(x);",
			"        validate(y);",
			"        int rootX = find(x);",
			"        int rootY = find(y);",
			"",
			"        if (rootX != rootY) {",
			"            --count;",
			"            // 按秩合并：将秩小的树合并到秩大的树上",
			"            if (rank[rootX] < rank[rootY]) {",
			"                parent[rootX] = rootY;",
			"            } else if (rank[rootX] > rank[rootY]) {",
			"                parent[rootY] = rootX;",
			"            } else {",
			"                parent[rootY] = rootX;",
			"                rank[rootX]++;  // 增加合并后的根的秩",
			"            }",
			"        }",
			"    }",
			"",
			"    // 判断两个元素是否属于同一集合",
			"    bool connected(int x, int y) {",
			"        validate(x);",
			"        validate(y);",
			"        return find(x) == find(y);",
			"    }",
			"",
			"    // 联通体的数量",
			"    int getCount(void) {",
			"        return count;",
			"    }",
			"",
			"    // 打印父节点数组和秩数组（调试用）",
			"    void print() {",
			"        std::cout << \"Parent array: \";",
			"        for (int i = 0; i < (int)parent.size(); ++i) {",
			"            std::cout << parent[i] << \" \";",
			"        }",
			"        std::cout << std::endl;",
			"",
			"        std::cout << \"Rank array: \";",
			"        for (int i = 0; i < (int)rank.size(); ++i) {",
			"            std::cout << rank[i] << \" \";",
			"        }",
			"        std::cout << std::endl;",
			"    }",
			"};"
		],
		"description": "UnionFind"
	},
	"kmp": {
		"prefix": "Templatekmp",
		"body": [
			"int kmp(const string& text, const string& pattern)",
			"{",
			"    int n = text.size(), m = pattern.size();",
			"    if (m == 0) {",
			"        return 0;",
			"    }",
			"    vector<int> next(m);",
			"    for (int i = 1, j = 0; i < m; i++) {",
			"        while (j > 0 && pattern[i] != pattern[j]) {",
			"            j = next[j - 1];",
			"        }",
			"        if (pattern[i] == pattern[j]) {",
			"            j++;",
			"        }",
			"        next[i] = j;",
			"    }",
			"    for (int i = 0, j = 0; i < n; i++) {",
			"        while (j > 0 && text[i] != pattern[j]) {",
			"            j = next[j - 1];",
			"        }",
			"        if (text[i] == pattern[j]) {",
			"            j++;",
			"        }",
			"        if (j == m) {",
			"            return i - m + 1;",
			"        }",
			"    }",
			"    return -1;",
			"}"
		],
		"description": "kmp"
	},
	"SegmentTree": {
		"prefix": "TemplateSegmentTree",
		"body": [
			"class SegmentTree {",
			"private:",
			"    vector<i64> left, right;",
			"    vector<i64> leftSon, rightSon;",
			"    i64         cnt = 1;",
			"    vector<i64> val;",
			"    i64         __n;",
			"",
			"    void update(i64 root, i64 idx, i64 value)",
			"    {",
			"        i64 l = left[root], r = right[root];",
			"        if (l == r) {",
			"            val[root] = value;",
			"            return;",
			"        }",
			"        i64 mid = (l + r) >> 1;",
			"        if (idx <= mid) {",
			"            if (leftSon[root] == 0) {",
			"                leftSon[root] = ++cnt;",
			"                leftSon.emplace_back(0);",
			"                rightSon.emplace_back(0);",
			"                val.emplace_back(0);",
			"                left.emplace_back(l);",
			"                right.emplace_back(mid);",
			"            }",
			"            update(leftSon[root], idx, value);",
			"        } else {",
			"            if (rightSon[root] == 0) {",
			"                rightSon[root] = ++cnt;",
			"                rightSon.emplace_back(0);",
			"                leftSon.emplace_back(0);",
			"                val.emplace_back(0);",
			"                left.emplace_back(mid + 1);",
			"                right.emplace_back(r);",
			"            }",
			"            update(rightSon[root], idx, value);",
			"        }",
			"        val[root] = (val[leftSon[root]] + val[rightSon[root]]);",
			"    }",
			"",
			"    i64 quary(i64 root, i64 start, i64 end)",
			"    {",
			"        if (val[root] == 0) {",
			"            return 0;",
			"        }",
			"        if (start > right[root] || end < left[root]) {",
			"            return 0;",
			"        }",
			"        i64 l = left[root], r = right[root];",
			"        if (start <= l && r <= end) {",
			"            return val[root];",
			"        }",
			"        i64 sum = 0;",
			"        if (leftSon[root] != 0) {",
			"            sum += quary(leftSon[root], start, end);",
			"        }",
			"",
			"        if (rightSon[root] != 0) {",
			"            sum += quary(rightSon[root], start, end);",
			"        }",
			"        return sum;",
			"    }",
			"",
			"public:",
			"    SegmentTree(i64 n) : left(2), right(2), leftSon(2, 0), rightSon(2, 0), val(2, 0), __n(n)",
			"    {",
			"        left[cnt]  = 1;",
			"        right[cnt] = n;",
			"    }",
			"",
			"    void update(i64 idx, i64 value)",
			"    {",
			"        if (idx > __n) {",
			"            perror(\"Index out of bound.(SegmentTree->update)\");",
			"            throw exception();",
			"        }",
			"        update(1, idx, value);",
			"    }",
			"",
			"    i64 quary(i64 l, i64 r)",
			"    {",
			"        if (l > r) {",
			"            perror(\"\\\"l\\\" could not larger than \\\"r\\\".(SegmentTree->quary)\");",
			"            throw exception();",
			"        }",
			"        if (l < 1 || r > __n) {",
			"            perror(\"Index out of bound.(SegmentTree->quary)\");",
			"            throw exception();",
			"        }",
			"        return quary(1, l, r);",
			"    }",
			"};"
		],
		"description": "SegmentTree"
	},
	"TreeArr": {
		"prefix": "TemplateTreeArr",
		"body": [
			"class TreeArr {",
			"private:",
			"    vector<int> bitArr;",
			"",
			"    int lowbit(int x)",
			"    {",
			"        return x & -x;",
			"    }",
			"",
			"public:",
			"    void update(int place, int value)",
			"    {",
			"        for (int i = place; i < bitArr.size(); i += lowbit(i)) {",
			"            bitArr[i] += value;",
			"        }",
			"    }",
			"",
			"    int query(int place)",
			"    {",
			"        int res = 0;",
			"        for (int i = place; i; i -= lowbit(i)) {",
			"            res += bitArr[i];",
			"        }",
			"        return res;",
			"    }",
			"};"
		],
		"description": "TreeArr"
	}
}